// Generated by rust-peg. Do not edit.
use self::RuleResult::{Failed, Matched};
use super::ast::*;
use super::{resolve_binary, resolve_logical};
fn escape_default(s: &str) -> String {
    s.chars().flat_map(|c| c.escape_default()).collect()
}
fn char_range_at(s: &str, pos: usize) -> (char, usize) {
    let c = &s[pos..].chars().next().unwrap();
    let next_pos = pos + c.len_utf8();
    (*c, next_pos)
}
#[derive(Clone)]
enum RuleResult<T> {
    Matched(usize, T),
    Failed,
}
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct ParseError {
    pub line: usize,
    pub column: usize,
    pub offset: usize,
    pub expected: ::std::collections::HashSet<&'static str>,
}
pub type ParseResult<T> = Result<T, ParseError>;
impl ::std::fmt::Display for ParseError {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::result::Result<(), ::std::fmt::Error> {
        write!(fmt, "error at {}:{}: expected ", self.line, self.column)?;
        if self.expected.len() == 0 {
            write!(fmt, "EOF")?;
        } else if self.expected.len() == 1 {
            write!(
                fmt,
                "`{}`",
                escape_default(self.expected.iter().next().unwrap())
            )?;
        } else {
            let mut iter = self.expected.iter();
            write!(fmt, "one of `{}`", escape_default(iter.next().unwrap()))?;
            for elem in iter {
                write!(fmt, ", `{}`", escape_default(elem))?;
            }
        }
        Ok(())
    }
}
impl ::std::error::Error for ParseError {
    fn description(&self) -> &str {
        "parse error"
    }
}
fn slice_eq(input: &str, state: &mut ParseState, pos: usize, m: &'static str) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let l = m.len();
    if input.len() >= pos + l && &input.as_bytes()[pos..pos + l] == m.as_bytes() {
        Matched(pos + l, ())
    } else {
        state.mark_failure(pos, m)
    }
}
fn slice_eq_case_insensitive(
    input: &str,
    state: &mut ParseState,
    pos: usize,
    m: &'static str,
) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    let mut used = 0usize;
    let mut input_iter = input[pos..].chars().flat_map(|x| x.to_uppercase());
    for m_char_upper in m.chars().flat_map(|x| x.to_uppercase()) {
        used += m_char_upper.len_utf8();
        let input_char_result = input_iter.next();
        if input_char_result.is_none() || input_char_result.unwrap() != m_char_upper {
            return state.mark_failure(pos, m);
        }
    }
    Matched(pos + used, ())
}
fn any_char(input: &str, state: &mut ParseState, pos: usize) -> RuleResult<()> {
    #![inline]
    #![allow(dead_code)]
    if input.len() > pos {
        let (_, next) = char_range_at(input, pos);
        Matched(next, ())
    } else {
        state.mark_failure(pos, "<character>")
    }
}
fn pos_to_line(input: &str, pos: usize) -> (usize, usize) {
    let before = &input[..pos];
    let line = before.as_bytes().iter().filter(|&&c| c == b'\n').count() + 1;
    let col = before.chars().rev().take_while(|&c| c != '\n').count() + 1;
    (line, col)
}
impl<'input> ParseState<'input> {
    fn mark_failure(&mut self, pos: usize, expected: &'static str) -> RuleResult<()> {
        if self.suppress_fail == 0 {
            if pos > self.max_err_pos {
                self.max_err_pos = pos;
                self.expected.clear();
            }
            if pos == self.max_err_pos {
                self.expected.insert(expected);
            }
        }
        Failed
    }
}
struct ParseState<'input> {
    max_err_pos: usize,
    suppress_fail: usize,
    expected: ::std::collections::HashSet<&'static str>,
    _phantom: ::std::marker::PhantomData<&'input ()>,
}
impl<'input> ParseState<'input> {
    fn new() -> ParseState<'input> {
        ParseState {
            max_err_pos: 0,
            suppress_fail: 0,
            expected: ::std::collections::HashSet::new(),
            _phantom: ::std::marker::PhantomData,
        }
    }
}

fn __parse_program<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<Stmt>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_statements(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { s }),
            Failed => Failed,
        }
    }
}

fn __parse_statements<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<Stmt>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let mut __repeat_pos = __pos;
            let mut __repeat_value = vec![];
            loop {
                let __pos = __repeat_pos;
                let __pos = if __repeat_value.len() > 0 {
                    let __sep_res = __parse___(__input, __state, __pos);
                    match __sep_res {
                        Matched(__newpos, _) => __newpos,
                        Failed => break,
                    }
                } else {
                    __pos
                };
                let __step_res = __parse_statement(__input, __state, __pos);
                match __step_res {
                    Matched(__newpos, __value) => {
                        __repeat_pos = __newpos;
                        __repeat_value.push(__value);
                    }
                    Failed => {
                        break;
                    }
                }
            }
            Matched(__repeat_pos, __repeat_value)
        };
        match __seq_res {
            Matched(__pos, s) => Matched(__pos, { s }),
            Failed => Failed,
        }
    }
}

fn __parse_statement<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Stmt> {
    #![allow(non_snake_case, unused)]
    __parse_expression_statement(__input, __state, __pos)
}

fn __parse_expression_statement<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Stmt> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse__(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse_expression(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, e) => {
                        let __seq_res = __parse__s(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Stmt::Expr(ExprStmt::new(e)) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_block<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<Stmt>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "{");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse___s(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_statements(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, s) => {
                                let __seq_res = __parse___s(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, "}");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { s }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_expression<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    __parse_assignment_expr(__input, __state, __pos)
}

fn __parse_assignment_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_left_hand_side(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, l) => {
                    let __seq_res = __parse___(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                let str_start = __pos;
                                match __parse_assignment_operator(__input, __state, __pos) {
                                    Matched(__newpos, _) => {
                                        Matched(__newpos, &__input[str_start..__newpos])
                                    }
                                    Failed => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, o) => {
                                    let __seq_res = __parse___(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            let __seq_res =
                                                __parse_assignment_expr(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, r) => Matched(__pos, {
                                                    Expr::Assign(AssignExpr::new(
                                                        Box::new(l),
                                                        Box::new(r),
                                                    ))
                                                }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_logical_or_expr(__input, __state, __pos),
        }
    }
}

fn __parse_left_hand_side<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_call_expr(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_member_expr(__input, __state, __pos),
        }
    }
}

fn __parse_call_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_member_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, m) => {
                let __seq_res = __parse_arguments(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, a) => {
                        Matched(__pos, { Expr::Call(CallExpr::new(Box::new(m), a)) })
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_arguments<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Vec<Expr>> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "(");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = match {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __pos = if __repeat_value.len() > 0 {
                                    let __sep_res = {
                                        let __seq_res = __parse___(__input, __state, __pos);
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                let __seq_res =
                                                    slice_eq(__input, __state, __pos, ",");
                                                match __seq_res {
                                                    Matched(__pos, _) => {
                                                        __parse___(__input, __state, __pos)
                                                    }
                                                    Failed => Failed,
                                                }
                                            }
                                            Failed => Failed,
                                        }
                                    };
                                    match __sep_res {
                                        Matched(__newpos, _) => __newpos,
                                        Failed => break,
                                    }
                                } else {
                                    __pos
                                };
                                let __step_res = __parse_logical_or_expr(__input, __state, __pos);
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        } {
                            Matched(__newpos, __value) => Matched(__newpos, Some(__value)),
                            Failed => Matched(__pos, None),
                        };
                        match __seq_res {
                            Matched(__pos, a) => {
                                let __seq_res = __parse___(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, {
                                                if a.is_some() {
                                                    a.unwrap()
                                                } else {
                                                    Vec::new()
                                                }
                                            }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_member_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_primary_expr(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, o) => {
                    let __seq_res = {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "[");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = __parse_expression(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, e) => {
                                            let __seq_res = slice_eq(__input, __state, __pos, "]");
                                            match __seq_res {
                                                Matched(__pos, _) => Matched(__pos, { e }),
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = slice_eq(__input, __state, __pos, ".");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = __parse_identifier(__input, __state, __pos);
                                        match __seq_res {
                                            Matched(__pos, i) => Matched(__pos, { i }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    };
                    match __seq_res {
                        Matched(__pos, p) => Matched(__pos, {
                            Expr::Member(MemberExpr::new(Box::new(o), Box::new(p), false))
                        }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_primary_expr(__input, __state, __pos),
        }
    }
}

fn __parse_primary_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_identifier(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, i) => Matched(__pos, { i }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = __parse_literal(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, l) => Matched(__pos, { l }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = slice_eq(__input, __state, __pos, "(");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = __parse_expression(__input, __state, __pos);
                                match __seq_res {
                                    Matched(__pos, e) => {
                                        let __seq_res = slice_eq(__input, __state, __pos, ")");
                                        match __seq_res {
                                            Matched(__pos, _) => Matched(__pos, { e }),
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_postfix_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_left_hand_side(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, v) => {
                    let __seq_res = __parse__s(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_POSTFIX_OPERATOR(__input, __state, __pos);
                            match __seq_res {
                                Matched(__pos, o) => {
                                    let __seq_res = __parse___(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, {
                                            Expr::Postfix(PostfixExpr::new(Box::new(v), o))
                                        }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_left_hand_side(__input, __state, __pos),
        }
    }
}

fn __parse_unary_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = __parse_UNARY_OPERATOR(__input, __state, __pos);
            match __seq_res {
                Matched(__pos, o) => {
                    let __seq_res = __parse___(__input, __state, __pos);
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = __parse_unary_expr(__input, __state, __pos);
                            match __seq_res {
                                Matched(__pos, v) => {
                                    let __seq_res = __parse___(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, {
                                            Expr::Unary(UnaryExpr::new(Box::new(v), o))
                                        }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => __parse_postfix_expr(__input, __state, __pos),
        }
    }
}

fn __parse_multiplicative_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_unary_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_MULTIPLICATIVE_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res =
                                                        __parse_unary_expr(__input, __state, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, e) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_additive_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_multiplicative_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_ADDITIVE_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_multiplicative_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, e) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, e) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_shift_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_additive_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res = __parse_SHIFT_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_additive_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_relational_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_shift_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_RELATIONAL_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res =
                                                        __parse_shift_expr(__input, __state, __pos);
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_equality_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_relational_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_EQUALITY_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_relational_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_bitwise_and_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_equality_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_BITWISE_AND_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_equality_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_bitwise_xor_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_bitwise_and_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_BITWISE_XOR_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_bitwise_and_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_bitwise_or_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_bitwise_xor_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_BITWISE_OR_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_bitwise_xor_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_binary(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_logical_and_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_equality_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_LOGICAL_AND_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_equality_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_logical(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_logical_or_expr<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = __parse_logical_and_expr(__input, __state, __pos);
        match __seq_res {
            Matched(__pos, l) => {
                let __seq_res = __parse___(__input, __state, __pos);
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            let mut __repeat_pos = __pos;
                            let mut __repeat_value = vec![];
                            loop {
                                let __pos = __repeat_pos;
                                let __step_res = {
                                    let __seq_res =
                                        __parse_LOGICAL_OR_OPERATOR(__input, __state, __pos);
                                    match __seq_res {
                                        Matched(__pos, o) => {
                                            let __seq_res = __parse___(__input, __state, __pos);
                                            match __seq_res {
                                                Matched(__pos, _) => {
                                                    let __seq_res = __parse_logical_and_expr(
                                                        __input, __state, __pos,
                                                    );
                                                    match __seq_res {
                                                        Matched(__pos, r) => {
                                                            let __seq_res =
                                                                __parse___(__input, __state, __pos);
                                                            match __seq_res {
                                                                Matched(__pos, _) => {
                                                                    Matched(__pos, { (o, r) })
                                                                }
                                                                Failed => Failed,
                                                            }
                                                        }
                                                        Failed => Failed,
                                                    }
                                                }
                                                Failed => Failed,
                                            }
                                        }
                                        Failed => Failed,
                                    }
                                };
                                match __step_res {
                                    Matched(__newpos, __value) => {
                                        __repeat_pos = __newpos;
                                        __repeat_value.push(__value);
                                    }
                                    Failed => {
                                        break;
                                    }
                                }
                            }
                            Matched(__repeat_pos, __repeat_value)
                        };
                        match __seq_res {
                            Matched(__pos, ops) => Matched(__pos, { resolve_logical(l, ops) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_literal<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __choice_res = __parse_literal_boolean(__input, __state, __pos);
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => {
                    let __choice_res = __parse_literal_number(__input, __state, __pos);
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => __parse_literal_string(__input, __state, __pos),
                    }
                }
            }
        };
        match __seq_res {
            Matched(__pos, lit) => Matched(__pos, { Expr::Literal(LiteralExpr::new(lit)) }),
            Failed => Failed,
        }
    }
}

fn __parse_literal_boolean<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Literal> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __choice_res = slice_eq(__input, __state, __pos, "true");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => slice_eq(__input, __state, __pos, "false"),
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, b) => Matched(__pos, {
                Literal::Boolean(if b == "true" { true } else { false })
            }),
            Failed => Failed,
        }
    }
}

fn __parse_literal_number<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Literal> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __choice_res = __parse_double(__input, __state, __pos);
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => __parse_int(__input, __state, __pos),
            }
        };
        match __seq_res {
            Matched(__pos, n) => Matched(__pos, { Literal::Number(n) }),
            Failed => Failed,
        }
    }
}

fn __parse_int<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Number> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __choice_res = slice_eq(__input, __state, __pos, "0");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = if __input.len() > __pos {
                            let (__ch, __next) = char_range_at(__input, __pos);
                            match __ch {
                                '1'...'9' => Matched(__next, ()),
                                _ => __state.mark_failure(__pos, "[1-9]"),
                            }
                        } else {
                            __state.mark_failure(__pos, "[1-9]")
                        };
                        match __seq_res {
                            Matched(__pos, _) => {
                                let mut __repeat_pos = __pos;
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-9]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                Matched(__repeat_pos, ())
                            }
                            Failed => Failed,
                        }
                    }
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, i) => Matched(__pos, { Number::Integer(i.parse().unwrap()) }),
            Failed => Failed,
        }
    }
}

fn __parse_double<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Number> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = {
                    let __choice_res = slice_eq(__input, __state, __pos, "0");
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => {
                            let __seq_res = if __input.len() > __pos {
                                let (__ch, __next) = char_range_at(__input, __pos);
                                match __ch {
                                    '1'...'9' => Matched(__next, ()),
                                    _ => __state.mark_failure(__pos, "[1-9]"),
                                }
                            } else {
                                __state.mark_failure(__pos, "[1-9]")
                            };
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let mut __repeat_pos = __pos;
                                    loop {
                                        let __pos = __repeat_pos;
                                        let __step_res = if __input.len() > __pos {
                                            let (__ch, __next) = char_range_at(__input, __pos);
                                            match __ch {
                                                '0'...'9' => Matched(__next, ()),
                                                _ => __state.mark_failure(__pos, "[0-9]"),
                                            }
                                        } else {
                                            __state.mark_failure(__pos, "[0-9]")
                                        };
                                        match __step_res {
                                            Matched(__newpos, __value) => {
                                                __repeat_pos = __newpos;
                                            }
                                            Failed => {
                                                break;
                                            }
                                        }
                                    }
                                    Matched(__repeat_pos, ())
                                }
                                Failed => Failed,
                            }
                        }
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = slice_eq(__input, __state, __pos, ".");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let mut __repeat_pos = __pos;
                                let mut __repeat_value = vec![];
                                loop {
                                    let __pos = __repeat_pos;
                                    let __step_res = if __input.len() > __pos {
                                        let (__ch, __next) = char_range_at(__input, __pos);
                                        match __ch {
                                            '0'...'9' => Matched(__next, ()),
                                            _ => __state.mark_failure(__pos, "[0-9]"),
                                        }
                                    } else {
                                        __state.mark_failure(__pos, "[0-9]")
                                    };
                                    match __step_res {
                                        Matched(__newpos, __value) => {
                                            __repeat_pos = __newpos;
                                            __repeat_value.push(__value);
                                        }
                                        Failed => {
                                            break;
                                        }
                                    }
                                }
                                if __repeat_value.len() >= 1 {
                                    Matched(__repeat_pos, ())
                                } else {
                                    Failed
                                }
                            }
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, i) => Matched(__pos, { Number::Double(i.parse().unwrap()) }),
            Failed => Failed,
        }
    }
}

fn __parse_literal_string<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Literal> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "\"");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let str_start = __pos;
                    match {
                        let mut __repeat_pos = __pos;
                        loop {
                            let __pos = __repeat_pos;
                            let __step_res = {
                                let __choice_res = __parse_raw_string(__input, __state, __pos);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => __parse_escape(__input, __state, __pos),
                                }
                            };
                            match __step_res {
                                Matched(__newpos, __value) => {
                                    __repeat_pos = __newpos;
                                }
                                Failed => {
                                    break;
                                }
                            }
                        }
                        Matched(__repeat_pos, ())
                    } {
                        Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                        Failed => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, s) => {
                        let __seq_res = slice_eq(__input, __state, __pos, "\"");
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { Literal::String(s.to_string()) }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_raw_string<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let mut __repeat_pos = __pos;
        let mut __repeat_value = vec![];
        loop {
            let __pos = __repeat_pos;
            let __step_res = {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "\\");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "\""),
                        }
                    };
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => any_char(__input, __state, __pos),
                    Failed => Failed,
                }
            };
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                }
                Failed => {
                    break;
                }
            }
        }
        if __repeat_value.len() >= 1 {
            Matched(__repeat_pos, ())
        } else {
            Failed
        }
    }
}

fn __parse_hex<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                '0'...'9' => Matched(__next, ()),
                _ => __state.mark_failure(__pos, "[0-9]"),
            }
        } else {
            __state.mark_failure(__pos, "[0-9]")
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = if __input.len() > __pos {
                    let (__ch, __next) = char_range_at(__input, __pos);
                    match __ch {
                        'a'...'f' => Matched(__next, ()),
                        _ => __state.mark_failure(__pos, "[a-f]"),
                    }
                } else {
                    __state.mark_failure(__pos, "[a-f]")
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        if __input.len() > __pos {
                            let (__ch, __next) = char_range_at(__input, __pos);
                            match __ch {
                                'A'...'F' => Matched(__next, ()),
                                _ => __state.mark_failure(__pos, "[A-F]"),
                            }
                        } else {
                            __state.mark_failure(__pos, "[A-F]")
                        }
                    }
                }
            }
        }
    }
}

fn __parse_unicode_hex<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let mut __repeat_pos = __pos;
        let mut __repeat_value = vec![];
        loop {
            let __pos = __repeat_pos;
            if __repeat_value.len() >= 6 {
                break;
            }
            let __step_res = __parse_hex(__input, __state, __pos);
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                    __repeat_value.push(__value);
                }
                Failed => {
                    break;
                }
            }
        }
        if __repeat_value.len() >= 1 {
            Matched(__repeat_pos, ())
        } else {
            Failed
        }
    }
}

fn __parse_predefined<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "n");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = slice_eq(__input, __state, __pos, "r");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "t");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, "\\");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = slice_eq(__input, __state, __pos, "0");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res =
                                                    slice_eq(__input, __state, __pos, "\"");
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        slice_eq(__input, __state, __pos, "'")
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_byte<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "x");
        match __seq_res {
            Matched(__pos, _) => {
                let mut __repeat_pos = __pos;
                let mut __repeat_value = vec![];
                loop {
                    let __pos = __repeat_pos;
                    if __repeat_value.len() >= 2 {
                        break;
                    }
                    let __step_res = __parse_hex(__input, __state, __pos);
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                            __repeat_value.push(__value);
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                if __repeat_value.len() >= 2 {
                    Matched(__repeat_pos, ())
                } else {
                    Failed
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_unicode<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "u");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = slice_eq(__input, __state, __pos, "{");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = __parse_unicode_hex(__input, __state, __pos);
                        match __seq_res {
                            Matched(__pos, _) => slice_eq(__input, __state, __pos, "}"),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_escape<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "\\");
        match __seq_res {
            Matched(__pos, _) => {
                let __choice_res = __parse_predefined(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_byte(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => __parse_unicode(__input, __state, __pos),
                        }
                    }
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_char_literal<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "'");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    let __choice_res = __parse_escape(__input, __state, __pos);
                    match __choice_res {
                        Matched(__pos, __value) => Matched(__pos, __value),
                        Failed => any_char(__input, __state, __pos),
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => slice_eq(__input, __state, __pos, "'"),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_token_this<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "this")
}

fn __parse_token_function<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "fn")
}

fn __parse_token_var<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "let")
}

fn __parse_token_return<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "return")
}

fn __parse_token_class<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "class")
}

fn __parse_token_true<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "true")
}

fn __parse_token_false<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "false")
}

fn __parse_token_if<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "if")
}

fn __parse_token_else<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "else")
}

fn __parse_token_for<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "for")
}

fn __parse_token_continue<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "continue")
}

fn __parse_token_break<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "break")
}

fn __parse_token_in<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "in")
}

fn __parse_POSTFIX_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<PostfixOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "++");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { PostfixOperator::Increment }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "--");
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { PostfixOperator::Decrement }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_UNARY_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<UnaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "++");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { UnaryOperator::Increment }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "--");
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { UnaryOperator::Decrement }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "+");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = slice_eq(__input, __state, __pos, "=");
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => {
                                            Matched(__pos, { UnaryOperator::Plus })
                                        }
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = slice_eq(__input, __state, __pos, "-");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res =
                                                slice_eq(__input, __state, __pos, "=");
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Failed => Matched(__pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                Matched(__pos, { UnaryOperator::Minus })
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_ADDITIVE_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "+");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let __assert_res = {
                            let __choice_res = slice_eq(__input, __state, __pos, "+");
                            match __choice_res {
                                Matched(__pos, __value) => Matched(__pos, __value),
                                Failed => slice_eq(__input, __state, __pos, "="),
                            }
                        };
                        __state.suppress_fail -= 1;
                        match __assert_res {
                            Failed => Matched(__pos, ()),
                            Matched(..) => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::Add }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "-");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = {
                                let __choice_res = slice_eq(__input, __state, __pos, "-");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => slice_eq(__input, __state, __pos, "="),
                                }
                            };
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { BinaryOperator::Sub }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_MULTIPLICATIVE_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "*");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let __assert_res = slice_eq(__input, __state, __pos, "=");
                        __state.suppress_fail -= 1;
                        match __assert_res {
                            Failed => Matched(__pos, ()),
                            Matched(..) => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::Mul }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, "/");
                    match __seq_res {
                        Matched(__pos, _) => {
                            let __seq_res = {
                                __state.suppress_fail += 1;
                                let __assert_res = slice_eq(__input, __state, __pos, "=");
                                __state.suppress_fail -= 1;
                                match __assert_res {
                                    Failed => Matched(__pos, ()),
                                    Matched(..) => Failed,
                                }
                            };
                            match __seq_res {
                                Matched(__pos, _) => Matched(__pos, { BinaryOperator::Div }),
                                Failed => Failed,
                            }
                        }
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __seq_res = slice_eq(__input, __state, __pos, "%");
                        match __seq_res {
                            Matched(__pos, _) => {
                                let __seq_res = {
                                    __state.suppress_fail += 1;
                                    let __assert_res = slice_eq(__input, __state, __pos, "=");
                                    __state.suppress_fail -= 1;
                                    match __assert_res {
                                        Failed => Matched(__pos, ()),
                                        Matched(..) => Failed,
                                    }
                                };
                                match __seq_res {
                                    Matched(__pos, _) => Matched(__pos, { BinaryOperator::Mod }),
                                    Failed => Failed,
                                }
                            }
                            Failed => Failed,
                        }
                    }
                }
            }
        }
    }
}

fn __parse_SHIFT_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "<<");
            match __seq_res {
                Matched(__pos, _) => {
                    let __seq_res = {
                        __state.suppress_fail += 1;
                        let __assert_res = slice_eq(__input, __state, __pos, "=");
                        __state.suppress_fail -= 1;
                        match __assert_res {
                            Failed => Matched(__pos, ()),
                            Matched(..) => Failed,
                        }
                    };
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::ShiftLeft }),
                        Failed => Failed,
                    }
                }
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, ">>");
                match __seq_res {
                    Matched(__pos, _) => {
                        let __seq_res = {
                            __state.suppress_fail += 1;
                            let __assert_res = slice_eq(__input, __state, __pos, "=");
                            __state.suppress_fail -= 1;
                            match __assert_res {
                                Failed => Matched(__pos, ()),
                                Matched(..) => Failed,
                            }
                        };
                        match __seq_res {
                            Matched(__pos, _) => Matched(__pos, { BinaryOperator::ShiftRight }),
                            Failed => Failed,
                        }
                    }
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_RELATIONAL_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "<=");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { BinaryOperator::Lte }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = {
                    let __seq_res = slice_eq(__input, __state, __pos, ">=");
                    match __seq_res {
                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::Gte }),
                        Failed => Failed,
                    }
                };
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = {
                            let __seq_res = slice_eq(__input, __state, __pos, "<");
                            match __seq_res {
                                Matched(__pos, _) => {
                                    let __seq_res = {
                                        __state.suppress_fail += 1;
                                        let __assert_res = slice_eq(__input, __state, __pos, "<");
                                        __state.suppress_fail -= 1;
                                        match __assert_res {
                                            Failed => Matched(__pos, ()),
                                            Matched(..) => Failed,
                                        }
                                    };
                                    match __seq_res {
                                        Matched(__pos, _) => Matched(__pos, { BinaryOperator::Lt }),
                                        Failed => Failed,
                                    }
                                }
                                Failed => Failed,
                            }
                        };
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __seq_res = slice_eq(__input, __state, __pos, ">");
                                match __seq_res {
                                    Matched(__pos, _) => {
                                        let __seq_res = {
                                            __state.suppress_fail += 1;
                                            let __assert_res =
                                                slice_eq(__input, __state, __pos, ">");
                                            __state.suppress_fail -= 1;
                                            match __assert_res {
                                                Failed => Matched(__pos, ()),
                                                Matched(..) => Failed,
                                            }
                                        };
                                        match __seq_res {
                                            Matched(__pos, _) => {
                                                Matched(__pos, { BinaryOperator::Gt })
                                            }
                                            Failed => Failed,
                                        }
                                    }
                                    Failed => Failed,
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_EQUALITY_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = {
            let __seq_res = slice_eq(__input, __state, __pos, "==");
            match __seq_res {
                Matched(__pos, _) => Matched(__pos, { BinaryOperator::Eq }),
                Failed => Failed,
            }
        };
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __seq_res = slice_eq(__input, __state, __pos, "!=");
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { BinaryOperator::Neq }),
                    Failed => Failed,
                }
            }
        }
    }
}

fn __parse_LOGICAL_AND_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<LogicalOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "&&");
        match __seq_res {
            Matched(__pos, _) => Matched(__pos, { LogicalOperator::And }),
            Failed => Failed,
        }
    }
}

fn __parse_LOGICAL_OR_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<LogicalOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "||");
        match __seq_res {
            Matched(__pos, _) => Matched(__pos, { LogicalOperator::Or }),
            Failed => Failed,
        }
    }
}

fn __parse_assignment_operator<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "*=");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = slice_eq(__input, __state, __pos, "/=");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "%=");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, "+=");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res = slice_eq(__input, __state, __pos, "-=");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res =
                                                    slice_eq(__input, __state, __pos, "<<=");
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        let __choice_res = slice_eq(
                                                            __input, __state, __pos, ">>=",
                                                        );
                                                        match __choice_res {
                                                            Matched(__pos, __value) => {
                                                                Matched(__pos, __value)
                                                            }
                                                            Failed => {
                                                                let __choice_res = slice_eq(
                                                                    __input, __state, __pos, ">>>=",
                                                                );
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => {
                                                                        Matched(__pos, __value)
                                                                    }
                                                                    Failed => {
                                                                        let __choice_res = slice_eq(
                                                                            __input, __state,
                                                                            __pos, "&=",
                                                                        );
                                                                        match __choice_res {
                                                                            Matched(
                                                                                __pos,
                                                                                __value,
                                                                            ) => Matched(
                                                                                __pos, __value,
                                                                            ),
                                                                            Failed => {
                                                                                let __choice_res =
                                                                                    slice_eq(
                                                                                        __input,
                                                                                        __state,
                                                                                        __pos,
                                                                                        "^=",
                                                                                    );
                                                                                match __choice_res {
                                                                                    Matched(
                                                                                        __pos,
                                                                                        __value,
                                                                                    ) => Matched(
                                                                                        __pos,
                                                                                        __value,
                                                                                    ),
                                                                                    Failed => {
                                                                                        let __choice_res = slice_eq ( __input , __state , __pos , "|=" ) ;
                                                                                        match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __seq_res = slice_eq ( __input , __state , __pos , "=" ) ; match __seq_res { Matched ( __pos , _ ) => { { __state . suppress_fail += 1 ; let __assert_res = slice_eq ( __input , __state , __pos , "=" ) ; __state . suppress_fail -= 1 ; match __assert_res { Failed => Matched ( __pos , ( ) ) , Matched ( .. ) => Failed , } } } Failed => Failed , } } }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_BITWISE_AND_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "&");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "&");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "="),
                        }
                    };
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { BinaryOperator::BitwiseAnd }),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_BITWISE_XOR_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "^");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = slice_eq(__input, __state, __pos, "=");
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { BinaryOperator::BitwiseXor }),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_BITWISE_OR_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<BinaryOperator> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = slice_eq(__input, __state, __pos, "|");
        match __seq_res {
            Matched(__pos, _) => {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = {
                        let __choice_res = slice_eq(__input, __state, __pos, "|");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "="),
                        }
                    };
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => Matched(__pos, { BinaryOperator::BitwiseOr }),
                    Failed => Failed,
                }
            }
            Failed => Failed,
        }
    }
}

fn __parse_SPREAD_OPERATOR<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    slice_eq(__input, __state, __pos, "...")
}

fn __parse_reserved_words<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = __parse_token_this(__input, __state, __pos);
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = __parse_token_function(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = __parse_token_var(__input, __state, __pos);
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = __parse_token_return(__input, __state, __pos);
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res =
                                            __parse_token_class(__input, __state, __pos);
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => {
                                                let __choice_res =
                                                    __parse_token_true(__input, __state, __pos);
                                                match __choice_res {
                                                    Matched(__pos, __value) => {
                                                        Matched(__pos, __value)
                                                    }
                                                    Failed => {
                                                        let __choice_res = __parse_token_false(
                                                            __input, __state, __pos,
                                                        );
                                                        match __choice_res {
                                                            Matched(__pos, __value) => {
                                                                Matched(__pos, __value)
                                                            }
                                                            Failed => {
                                                                let __choice_res = __parse_token_if(
                                                                    __input, __state, __pos,
                                                                );
                                                                match __choice_res {
                                                                    Matched(__pos, __value) => {
                                                                        Matched(__pos, __value)
                                                                    }
                                                                    Failed => {
                                                                        let __choice_res =
                                                                            __parse_token_else(
                                                                                __input, __state,
                                                                                __pos,
                                                                            );
                                                                        match __choice_res {
                                                                            Matched(
                                                                                __pos,
                                                                                __value,
                                                                            ) => Matched(
                                                                                __pos, __value,
                                                                            ),
                                                                            Failed => {
                                                                                let __choice_res = __parse_token_for ( __input , __state , __pos ) ;
                                                                                match __choice_res {
                                                                                    Matched(
                                                                                        __pos,
                                                                                        __value,
                                                                                    ) => Matched(
                                                                                        __pos,
                                                                                        __value,
                                                                                    ),
                                                                                    Failed => {
                                                                                        let __choice_res = __parse_token_continue ( __input , __state , __pos ) ;
                                                                                        match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => { let __choice_res = __parse_token_break ( __input , __state , __pos ) ; match __choice_res { Matched ( __pos , __value ) => Matched ( __pos , __value ) , Failed => __parse_token_in ( __input , __state , __pos ) } } }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_identifier<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<Expr> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let str_start = __pos;
            match {
                let __seq_res = {
                    __state.suppress_fail += 1;
                    let __assert_res = __parse_reserved_words(__input, __state, __pos);
                    __state.suppress_fail -= 1;
                    match __assert_res {
                        Failed => Matched(__pos, ()),
                        Matched(..) => Failed,
                    }
                };
                match __seq_res {
                    Matched(__pos, _) => __parse_identifier_name(__input, __state, __pos),
                    Failed => Failed,
                }
            } {
                Matched(__newpos, _) => Matched(__newpos, &__input[str_start..__newpos]),
                Failed => Failed,
            }
        };
        match __seq_res {
            Matched(__pos, i) => Matched(__pos, {
                Expr::Identifier(IdentifierExpr::new(i.to_string()))
            }),
            Failed => Failed,
        }
    }
}

fn __parse_identifier_name<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = if __input.len() > __pos {
            let (__ch, __next) = char_range_at(__input, __pos);
            match __ch {
                'a'...'z' | 'A'...'Z' => Matched(__next, ()),
                _ => __state.mark_failure(__pos, "[a-zA-Z]"),
            }
        } else {
            __state.mark_failure(__pos, "[a-zA-Z]")
        };
        match __seq_res {
            Matched(__pos, _) => {
                let mut __repeat_pos = __pos;
                loop {
                    let __pos = __repeat_pos;
                    let __step_res = if __input.len() > __pos {
                        let (__ch, __next) = char_range_at(__input, __pos);
                        match __ch {
                            'a'...'z' | 'A'...'Z' => Matched(__next, ()),
                            _ => __state.mark_failure(__pos, "[a-zA-Z]"),
                        }
                    } else {
                        __state.mark_failure(__pos, "[a-zA-Z]")
                    };
                    match __step_res {
                        Matched(__newpos, __value) => {
                            __repeat_pos = __newpos;
                        }
                        Failed => {
                            break;
                        }
                    }
                }
                Matched(__repeat_pos, ())
            }
            Failed => Failed,
        }
    }
}

fn __parse_whitespace<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "\t");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = slice_eq(__input, __state, __pos, "\\v");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "\\f");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, " ");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => {
                                        let __choice_res =
                                            slice_eq(__input, __state, __pos, "\u{a0}");
                                        match __choice_res {
                                            Matched(__pos, __value) => Matched(__pos, __value),
                                            Failed => slice_eq(__input, __state, __pos, "\u{feff}"),
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse_line_terminator<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "\n");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = slice_eq(__input, __state, __pos, "\r");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "\u{2028}");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => slice_eq(__input, __state, __pos, "\u{2029}"),
                        }
                    }
                }
            }
        }
    }
}

fn __parse_line_terminator_sequence<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __choice_res = slice_eq(__input, __state, __pos, "\n");
        match __choice_res {
            Matched(__pos, __value) => Matched(__pos, __value),
            Failed => {
                let __choice_res = slice_eq(__input, __state, __pos, "\r\n");
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => {
                        let __choice_res = slice_eq(__input, __state, __pos, "\r");
                        match __choice_res {
                            Matched(__pos, __value) => Matched(__pos, __value),
                            Failed => {
                                let __choice_res = slice_eq(__input, __state, __pos, "\u{2028}");
                                match __choice_res {
                                    Matched(__pos, __value) => Matched(__pos, __value),
                                    Failed => slice_eq(__input, __state, __pos, "\u{2029}"),
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

fn __parse__<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let mut __repeat_pos = __pos;
        loop {
            let __pos = __repeat_pos;
            let __step_res = __parse_whitespace(__input, __state, __pos);
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                }
                Failed => {
                    break;
                }
            }
        }
        Matched(__repeat_pos, ())
    }
}

fn __parse___<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let mut __repeat_pos = __pos;
        loop {
            let __pos = __repeat_pos;
            let __step_res = {
                let __choice_res = __parse_whitespace(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_line_terminator_sequence(__input, __state, __pos),
                }
            };
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                }
                Failed => {
                    break;
                }
            }
        }
        Matched(__repeat_pos, ())
    }
}

fn __parse__s<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let __seq_res = {
            let __choice_res = slice_eq(__input, __state, __pos, "\n");
            match __choice_res {
                Matched(__pos, __value) => Matched(__pos, __value),
                Failed => slice_eq(__input, __state, __pos, ";"),
            }
        };
        match __seq_res {
            Matched(__pos, _) => __parse__(__input, __state, __pos),
            Failed => Failed,
        }
    }
}

fn __parse___s<'input>(
    __input: &'input str,
    __state: &mut ParseState<'input>,
    __pos: usize,
) -> RuleResult<()> {
    #![allow(non_snake_case, unused)]
    {
        let mut __repeat_pos = __pos;
        loop {
            let __pos = __repeat_pos;
            let __step_res = {
                let __choice_res = __parse_whitespace(__input, __state, __pos);
                match __choice_res {
                    Matched(__pos, __value) => Matched(__pos, __value),
                    Failed => __parse_line_terminator_sequence(__input, __state, __pos),
                }
            };
            match __step_res {
                Matched(__newpos, __value) => {
                    __repeat_pos = __newpos;
                }
                Failed => {
                    break;
                }
            }
        }
        Matched(__repeat_pos, ())
    }
}

pub fn program<'input>(__input: &'input str) -> ParseResult<Vec<Stmt>> {
    #![allow(non_snake_case, unused)]
    let mut __state = ParseState::new();
    match __parse_program(__input, &mut __state, 0) {
        Matched(__pos, __value) => {
            if __pos == __input.len() {
                return Ok(__value);
            }
        }
        _ => {}
    }
    let (__line, __col) = pos_to_line(__input, __state.max_err_pos);
    Err(ParseError {
        line: __line,
        column: __col,
        offset: __state.max_err_pos,
        expected: __state.expected,
    })
}
